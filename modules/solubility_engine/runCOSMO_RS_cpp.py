#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan 12 11:15:24 2024

@author: cgic

Code to run the openCOSMO-RS python packages with cosmo files generated by orca to calcuate activity coefficients or solubility

cpp: added the c++ implementation to allow for 25 version of the method

v13: added extra (fraction) condition for saturation solubility convergence
and add successive over-relaxation to avoid loops in solubility iteration

v12: fixed problems with doing only activity cfs
and edited wording of some outputs for clarity

v11: fixed bug with reading Tm if lower than working temp

v10: change chemical potential conformer treatement from weighted average to 
conformational partition funciton

v8: Make this version automatically iterate to a saturated solubility

v7: This version is to automate conformer calculations of refstates to get 
final calculations wrt a realistic mixture of conformers of a pure molecule
Calculates conformer fractions for each molecule inputted
Then calculates conformer fractions for the inputted mixture
Then gets activity coefficients for mixture components wrt refstate of each pure
molecules (conformer mix) in turn

v7 additions: fix issue if there is a very small numerical difference between
calculated fractions of conformers and target mol fraction of component

"""



import numpy as np
import sys
import inspect

import sys
import inspect
from pathlib import Path

# Import modules
from opencosmorspy import Parameterization, COSMORS
from opencosmorspy.parameterization import openCOSMORS24a
import openCOSMORS

import math
import mpmath
import statistics as stat
import datetime
import sys
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors

start = datetime.datetime.now()

options = {

    'sw_skip_COSMOSPACE_errors' : 0,                                # whether to skip COSMOSPACE errors in the case a parameter makes the equations unsolvable
                                                                    # this is handy when running optimizations of the parameters of COSMO-RS
                                                                    # you still need to catch the error and handle it approprietlywhether to skip COSMOSPACE errors in the case a parameter makes the equations unsolvable
    # input switches
    'sw_SR_COSMOfiles_type': 'ORCA_COSMO_TZVPD',                # ['Turbomole_COSMO_TZVP', 'Turbomole_COSMO_TZVPD_FINE', 'ORCA_COSMO_TZVPD']
    'sw_SR_combTerm': 1, # 0 No combinatorial term
                         # 1 to use the combinatorial term by Staverman-Guggenheim
                         # 2 to use the combinatorial term by Klamt (2003)
                         # 3 to use modified Staverman-Guggenheim combinatorial term with exponential scaling */

    # optional calculation switches
    'sw_SR_alwaysReloadSigmaProfiles': 0,
    'sw_SR_alwaysCalculateSizeRelatedParameters': 1,
    'sw_SR_useSegmentReferenceStateForInteractionMatrix': 0,        # [0, 1] 
                                                                    #       0 : conductor
                                                                    #       1 : pure segment
    'sw_SR_calculateContactStatisticsAndAdditionalProperties': 2,   # [0, 1, 2]
                                                                    #       0 : do not calculate anything additionaly
                                                                    #       1 : calculate contact statistics and average surface energies
                                                                    #       2 : calculate contact statistics, average surface energies and partial molar properties
    'sw_SR_partialInteractionMatrices' : [],                        # partial interaction matrices to be calculated as partial mlar properties
                                                                    # examples are ['E_mf', 'G_hb'], these must however also be added on the C++ side
    
                                                                  
    # segment descriptor switches
    'sw_SR_atomicNumber': 1,                                        # [0, 1] : differentiate between atomic numbers
    'sw_SR_misfit': 2,                                              # [0, 1, 2]
                                                                    #       0: do not use misfit correlation
                                                                    #       1 : use misfit correlation on all molecules
                                                                    #       2 : use misfit correlation only on neutral molecules
    'sw_SR_differentiateHydrogens' : 0,                             # [0, 1] : differentiate between hydrogen atoms depending on the heteroatom they are bound to
    'sw_SR_differentiateMoleculeGroups' : 0,  
    'sw_SR_polarizabilities' : 7                      # [0,1,3,5,6,7,8] : polarizability projections modes. Parametrizations and notations are from https://doi.org/10.1016/j.ces.2025.122170. 1 - Eq.(16)+ð‘¤1(Eq.(9)), 6 - Eq.(16)+ð‘¤5(Eq.(11)), 7 - Eq.(24)+ð‘¤5(Eq.(11)), 8 - Eq.(25)+ð‘¤5(Eq.(11)).  

}

# parameters (parameters below are the latest parametrization with polarizability projections: Eq.(24)+ð‘¤5(Eq.(11))) from https://doi.org/10.1016/j.ces.2025.122170. 
parameters = {  
    'Aeff': 4.90825,
    'alpha': 7876000.0,
    'CHB': 49318000.0,
    'CHBT': 1.5,
    'SigmaHB': 0.009953,
    'Rav': 0.5,
    'RavCorr': 1,
    'fCorr': 2.4,
    'comb_SG_z_coord': 0.0,
    'comb_SG_A_std': 1.0,
    'comb_modSG_exp': 2.0/3.0,
    'comb_lambda0': 0.463,
    'comb_lambda1': 0.42,
    'comb_lambda2': 0.065,
    'comb_SGG_lambda': 0.773,
    'comb_SGG_beta': 0.778,
    'm_vdW':29.567 ,
    'E_F_corr':346.82,

    'radii': {},

    'exp': {}
}


def fill_missing_calculation_structures(calculations, options):

    for i, calculation in enumerate(calculations):

        number_of_components = calculation['concentrations'].shape[1]
        number_of_concentrations = calculation['concentrations'].shape[0]

        calculation['ln_gamma_x_SR_combinatorial_calc'] = np.zeros((number_of_concentrations, number_of_components))
        calculation['ln_gamma_x_SR_residual_calc'] = np.zeros((number_of_concentrations, number_of_components))
        calculation['ln_gamma_x_SR_calc'] = np.zeros((number_of_concentrations, number_of_components))
        calculation['index'] = i

        if options['sw_SR_calculateContactStatisticsAndAdditionalProperties'] > 0:
            # one for Aij + number of  partial interaction matrices
            number_of_interaction_matrices = 1 + len(options['sw_SR_partialInteractionMatrices'])
            
            calculation['contact_statistics'] = np.zeros((number_of_concentrations, number_of_components, number_of_components))
            calculation['average_surface_energies'] = np.zeros((number_of_concentrations, number_of_interaction_matrices, number_of_components, number_of_components))

            if options['sw_SR_calculateContactStatisticsAndAdditionalProperties'] == 2:
                calculation['partial_molar_energies'] = np.zeros((number_of_concentrations, number_of_interaction_matrices, number_of_components))
    return calculations

# Read input file containing a list of the molecules and information about their conformers
with open('mixture_inputs.txt','r') as f:
    inputs = f.readlines()

# constants
kB = 1.3806504e-23  # Boltzmann constant, J/K
kB_Hart = 3.166811563e-6  # Boltzmann constant, Hartree/K
R = 8.31446261815324/1000      # Gas constant in kJ K^-1 mol^-1
kjpermol2Hart = 0.0003808798033989866   # kJ per mol to Hartree convertor

# settings for iteration
meantol = 0.000001      # Tolerance for mean absolute difference between all chemical potentials 0.000001
maxtol = 0.000003       # Tolerance for max absolute difference between all chemical potentials 0.000003

# This tolerance is relevant if iterating to find solubility of a molecule at saturation
sat_tol = 0.000001     # Tolerance for absolute differce between iterations for mole fraction of molecule of interest
sat_tol_frac = 0.0001    # Difference in solubilities needs to be less than this *calculated solubility

def dist(coord0,coord1):
    """
    Function to find the distance between points in 3D space
    Args:
        coord0 (list): List of 3 coordinates x,y,z
        coord1 (list): List of 3 coordinates x,y,z
    Returns:
        dist (float): The distance between the points
    """
    xdist = coord0[0] - coord1[0]
    ydist = coord0[1] - coord1[1]
    zdist = coord0[2] - coord1[2]
    sumsqs = xdist**2 + ydist**2 + zdist**2
    dist = math.sqrt(sumsqs)
    return(dist)

# Function to get the overall chemical potential from the conformational partition function
def confpartfun(lngams,en_qms):
    """
    Function to get the overall chemical potential from activity coefficients of conformers using the conformational partition function
    Args:
        lngams (list): List of ln(activity coefficient) values for all conformers of a molecule
        en_qms (list): List of energies of all conformers of a molecule calculated using quantum chemistry
    Returns:
        overallmu (float): The overall chemical potential of the molecule
    """
    mus = []
    for i in range(len(lngams)):
        mus.append(lngams[i]*R*T)
    E0 = min(en_qms)
    insidesum = []
    for i in range(len(mus)):
        insidesum.append(math.exp(-(en_qms[i]-E0+mus[i])/(R*T)))
    partition = sum(insidesum)
    overallmu = -R*T*math.log(partition)
    return(overallmu)

def GfusMY(T,Tm,smiles):
    """
    Function to estimate Delta G(fusion) using the Method of Myrdal and Yalkowsky (1997)
    https://doi.org/10.1021/ie950242l
    Referred to in Environmental Organic Chemisty, Schwarsenbach, Ch4, ISBN:978-0-471-64964-9
    Args:
        T (float): Working temperature
        Tm (float): Melting point of the molecule
        smiles (str): The SMILES string of the molecule
    Returns:
        DeltG (float): The estimated free energy of fusion
    """
    # read in molecules
    molecule = Chem.MolFromSmiles(smiles)
    # Add Hs
    molecule = Chem.rdmolops.AddHs(molecule)
    # Tao calculation
    num_nontermsp3 = 0
    num_nontermsp2 = 0
    for atom in molecule.GetAtoms():
        if atom.GetHybridization() == Chem.rdchem.HybridizationType.SP3 and atom.GetDegree() > 1 and atom.IsInRing() == False:
            num_nontermsp3 += 1
        if atom.GetHybridization() == Chem.rdchem.HybridizationType.SP2 and atom.GetDegree() > 1 and atom.IsInRing() == False:
            num_nontermsp2 += 1
            
    numrings = rdMolDescriptors.CalcNumRings(molecule)

    tao = num_nontermsp3 + 0.5*num_nontermsp2 + 0.5*numrings - 1

    # Remove Hs (to avoid combinatorial explosion)
    molecule = Chem.rdmolops.RemoveHs(molecule)
    # Get symmetry number
    sigma = len(molecule.GetSubstructMatches(molecule, uniquify=False))

    # Delta G calculation
    DeltG = (56.5+9.2*tao-19.2*math.log(sigma,10))*(Tm-T)/1000
    return(DeltG)
    
def conf_calcs(molecules,confs_of,mults,mol_frac,T):
    """
    Function to iteratively determine relative populations of different conformers of molecules in a mixture of given composition 
    Args:
        molecules (list): The list of input molecules/conformers
        confs_of (list): Associates each conformer with a molecule
        mults (list): Degeneracy of each conformer
        T (float): Temperature, needed for converting between activity and chemical potential and for COSMO-RS calculations
    Returns:
        mus (list): Chemical potentials of all molecules/conformers at equilibrium conformer concentrations
        temp_res (list): COSMO-RS results
        all_molfracs (list): mole fractions of all conformers at equilibrium conformer concenrtations
        all_molweights (list): fractions of each conformer within its molecule at equilibrium conformer concentrations
    """
    print('\n')
    print('Starting a conformer weights calculation')

    # Use the python implementation of openCOSMO-RS to get the COSMO energies of each component
    crs = COSMORS(par=openCOSMORS24a())
    crs.par.calculate_contact_statistics_molecule_properties = True
    crs.clear_molecules()
    for i in range(len(molecules)):
        crs.add_molecule([molecules[i]])
    en_tots = []
    for i in range(len(molecules)):
        en_tot = crs.enth.mol_lst[i].cosmo_struct_lst[0].energy_tot
        en_tots.append(en_tot)
    
    mpmath.mp.dps = 300     # Precision for the maths to be done later

    # Initial guess of chemical potentials - 0 for all molecules
    mus = [0]*len(molecules)
    # Initial differences infinity - later these will be differences in mu between iterations
    mus_diff = [float('inf')]*len(molecules)
    
    mus_diff_mean = stat.mean(mus_diff)
    mus_diff_max = max(mus_diff)
    
    print('mu list:',mus)
    print('mu differences:',mus_diff)
    print('mean mu difference:',mus_diff_mean)
    print('max mu difference:',mus_diff_max)
    
    count = 0   # Number of iterations
    # Start conformer iterations - to solve conformer populations equation in COSMO-RS book
    # (COSMO-RS: From Quantum Chemistry to Fluid Phase Thermodynamics and Drug Design, Klamt 2005)
    while stat.mean(mus_diff) > meantol or max(mus_diff) > maxtol:
        print('\n')
        print('Iteration {0}'.format(count))
        print('------------------------------------------------------------------')
        
        all_molfracs=[]
        all_molweights=[]       # Will be the weights of conformers within each molecule, not weighted by mol frac - to avoid possible div 0 when averaging
        for i in range(len(mol_frac)):      # Loop through molecules (not conformers)
            weights_mol = []        # For result of eqn 7.8 in COSMO-RS book
            distrib_mol = []       # For numerator of eqn 7.8 in COSMO-RS book
            mus_mol = []          # List for the chemical potentials of the conformers of the molecule
            en_tots_mol = []     # List of the total COSMO energies of the conformers of the molecule
            mults_mol = []      # List of the degeneracies for the conformers of the molecule
            molfrac_mol = mol_frac[i]   # The mol fraction of the molecule (will be sum of conformer mol fracs)
            nconfs = 0      # Count conformers of moleucle
            for j in range(len(confs_of)):      # loop through all conformers to find the ones in the relevant molecule
                if confs_of[j] == i:
                    nconfs += 1
                    mus_mol.append(mus[j])
                    en_tots_mol.append(en_tots[j])
                    mults_mol.append(mults[j])
            
            for j in range(nconfs):   # Loop through conformers of moleucle
                E_COSMO = en_tots_mol[j]    # COSMO energy in kj/mol
                mu = mus_mol[j]
                mult = mults_mol[j]
                
                toexp = -(E_COSMO + mu)/(R*T)       # Experession to go in the exponential in eqn 7.8
                term = mult*(mpmath.exp(np.float128((toexp))))  # Need mpmath because numpy can't handle size of exponential
                distrib_mol.append(term)
            for j in range(nconfs):
                weights_mol.append(float(distrib_mol[j]/sum(distrib_mol)))
            print('Conformer Weights (molecule {0}):'.format(i),weights_mol)
            print('Sum of conformer weights for molecule {0}:'.format(i),sum(weights_mol),'(If not 1.0 then something has gone wrong)')
            
            # If sum of conformer weights differs from 1 by a small amount, reweight to sum to 1 (from python numerical precision)
            if sum(weights_mol) !=1 and abs(sum(weights_mol)-1) <= 1e-15:
                weights_mol_new = []
                for j in range(len(weights_mol)):
                    weights_mol_new.append(weights_mol[j]/sum(weights_mol))
                print('Reweighted conformer weights (molecule {0}):'.format(i),weights_mol_new)
                print('Sum of reweighted conformer weights for molecule {0}:'.format(i),sum(weights_mol_new))
                weights_mol = weights_mol_new
            
            conf_molfracs = []  # to make list of mol fractions of all conformers in mixture
            for j in range(nconfs):
                conf_molfracs.append(weights_mol[j]*molfrac_mol)
                all_molfracs.append(weights_mol[j]*molfrac_mol)
                all_molweights.append(weights_mol[j])
            print('Conformer mol fractions (molecule {0}):'.format(i),conf_molfracs)
        print('All mol fractions (mixture):',all_molfracs)
        print('Sum of mol fractions (mixture):',sum(all_molfracs))
        
        # Run COSMO-RS calculations with cosmo refstate and current mol fractions to get new mus
        # from resulting activities and hence new mol fractions
        x = np.array([all_molfracs])

        calculation = {
                'concentrations': x,
                'temperatures' : np.array([T]),
                'components' : strucs,
                'reference_state_types' : np.array([3]),
                'reference_state_concentrations' : np.array([[]]),
                'component_indices' : [i for i in range(len(all_molfracs))]
                }
        calculations = [calculation]

        calculations = fill_missing_calculation_structures(calculations, options)

        print(calculations[0]['concentrations'])

        openCOSMORS.initialize()
        openCOSMORS.loadMolecules(options, parameters, strucs)
        openCOSMORS.loadCalculations(calculations)
        # Run COSMO-RS with a particular set of mole fractions
        calculations = openCOSMORS.calculate(parameters, calculations, False)
       
        print('\n')
        print('Total logarithmic activity coefficient: \n', calculations[0]['ln_gamma_x_SR_calc'])
        print('Residual logarithmic activity coefficient: \n',calculations[0]['ln_gamma_x_SR_residual_calc'])
        print('Combinatorial logarithmic activity coefficient: \n',calculations[0]['ln_gamma_x_SR_combinatorial_calc'])
        print('\n')

        prev_mus = mus[:]    
        
        for i in range(len(mus)):
            mus[i] = float(calculations[0]['ln_gamma_x_SR_calc'].tolist()[0][i])*R*T   # New total chemical potentials of components read from COSMO results (in kJ/mol) 
            mus_diff[i] = abs(mus[i] - prev_mus[i])     # Difference between current and previous mu - this needs to converge in iteration
    
        mus_diff_mean = stat.mean(mus_diff)
        mus_diff_max = max(mus_diff)
 
        count += 1      # Count iterations
        print('Previous mu list:',prev_mus)
        print('Current mu list:',mus)
        print('Mu absolute differences:',mus_diff)
        print('Mean absolute difference:',mus_diff_mean)
        print('Max absolute difference:',mus_diff_max)
    
    print('Chemical potentials have converged to within {0} kJ/mol (mean) and {1} kJ/mol (max)'.format(meantol,maxtol))
    return(mus,calculations,all_molfracs,all_molweights,en_tots)

def run_saturation(x,refstate,molfrac_diff,new_molfrac_partition,molfrac_tosat):
    """Function to perform iterations to calculate the solubility of a solute via activity coefficients using an initial guess concentration
    Args:
        x (np.array): Array containing the initial guess populations of each component
        refstate: 'pure_component' if refstate is pure component or else array containing refstate populations
        molfrac_diff: Initial placeholder for differences between mole fractions in iterations
        new_molfrac_partition: Initial placeholder for new mole fraction
        molfrac_tosat: Initial placeholder for mole fraction of saturating molecules
    """
    iterno = 0
    while molfrac_diff > sat_tol or molfrac_diff/new_molfrac_partition > sat_tol_frac:
        old_molfrac = new_molfrac_partition     # Need to set what old_molfrac is for first iteration because it is used in successive over-relaxation
        iterno += 1

        print('----------------------')
        print('Saturation iteration ',iterno)
        
        # Get a variable of the current mole fractions of components to be updated at iterations
        allnewfracs = []
        for i in range(len(mol_frac)):
            allnewfracs.append(mol_frac[i])
        
        # Get a variable of the current mole fractions of conformers to be updated at iterations
        new_all_molfracs_mix = []
        for i in range(len(all_molfracs_mix)):
            new_all_molfracs_mix.append(all_molfracs_mix[i])
            
        # Get a variable of the current mole weights to be updated at iterations
        new_molweights_mix = []
        for i in range(len(molweights_mix)):
            new_molweights_mix.append(molweights_mix[i])
        
        # Specify the refstate
        if refstate == 'pure_component':
            reftypes = 0
            refconcs = np.array([[]])
        else:
            reftypes = 2
            refconcs = np.array([refstate])

        # Establish calculations settings
        calculation = {
                'concentrations': x,
                'temperatures' : np.array([T]),
                'components' : strucs,
                'reference_state_types' : np.array([reftypes]),
                'reference_state_concentrations' : refconcs,
                'component_indices' : [i for i in range(len(x[0]))]
        }
        calculations = [calculation]

        calculations = fill_missing_calculation_structures(calculations,options)

        # Initialize openCOSMORS, load molecules and calculation
        openCOSMORS.initialize()
        openCOSMORS.loadMolecules(options,parameters,strucs)
        openCOSMORS.loadCalculations(calculations)
        # Run COSMO-RS with a particular set of mole fractions
        calculations = openCOSMORS.calculate(parameters, calculations, False)

        # Obtain overall ln gamma for this set of mole fractions
        tosat_inds = []         # The indices referring to the conformers of the molecule to be saturated
        tosat_lngams = []       # ln activity coefficients of solute conformers
        tosat_molweights = []   # weights of solute conformers
        tosat_enqms = []        # QM energies of solute conformers
        for i in range(len(confs_of)):
            if confs_of[i] == mol_to_sat:
                tosat_inds.append(i)
                tosat_lngams.append(calculations[0]['ln_gamma_x_SR_calc'][0][i])       
                tosat_molweights.append(new_molweights_mix[i])
                tosat_enqms.append(en_tots[i])
        mu_partition = confpartfun(tosat_lngams, tosat_enqms)
        lngam_partition = mu_partition/(R*T)
        
        # Find solubility concentration for this gamma
        if Tm == 'liquid':
            new_molfrac_partition = 1/math.exp(lngam_partition)
        else:
            new_molfrac_partition = (1/math.exp(lngam_partition))*math.exp(-Gfus/(R*T))
            
        # successive over-relaxation
        new_molfrac_partition = w*new_molfrac_partition + (1-w)*old_molfrac

        print('New mole fraction: ',new_molfrac_partition)
        with open('sols_at_its.txt','a') as f:
            f.write('Iteration {0}\t Solubility {1} \n'.format(iterno,new_molfrac_partition))

        # Find the difference between the old and new mole fractions - for the end condition
        molfrac_diff = abs(new_molfrac_partition-molfrac_tosat)
        
        # Set new mole fractions according to the x that was found
        molfrac_tosat = new_molfrac_partition
        for i in range(len(mol_frac)):
            if i == mol_to_sat:
                allnewfracs[i] = molfrac_tosat
            else:
                allnewfracs[i] = (1-molfrac_tosat) * (mol_frac[i]/(sum(mol_frac)-mol_frac[mol_to_sat]))
        
        # Find new conformer fractions and weights based on the new mole fractions
        new_mus_mix,new_last_it_res_mix,new_all_molfracs_mix,new_molweights_mix,new_en_tots = conf_calcs(strucs,confs_of,mults,allnewfracs,T=T)
        
        # Set new x (mole fractions) for next iteration
        x = np.array([new_all_molfracs_mix])
        
    return(new_all_molfracs_mix,calculations,new_molweights_mix,molfrac_tosat)

# Setting up variables with COSMO output ready to work with

# Read the input file and set up varaibles with the information it contains defining the mixture
calc_type = inputs[0].split()[1]
if calc_type != 'all' and calc_type != 'mixed_only' and calc_type != 'pure_only':
    sys.exit('Calculation type must be all or mixed_only or pure_only')

T = float(inputs[1].split()[1])
print('Temperature = {0} K \n'.format(T))

sat = inputs[2].split()[1]  # whether to iterate to saturation and which molecule is the solute
Tm = inputs[3].split()[1]   # melting point or indication that it is not needed
Gfus_input = inputs[4].split()[1] # free energy of fusion or information about how it will be obtained or that it is not needed
Hfus = inputs[5].split()[1] # enthalpy of fusion
if sat != 'no' and Gfus_input == 'MyrdalYalkowsky':
    SMILES = inputs[2].split()[2]   # SMILES string of the molecule to be saturated - needed if using MY 
try:
    w = float(inputs[6].split()[1])    # successive over relaxation coefficient
except:
    w = 1
    print('Number not given for successive over relaxation coefficient. If doing solubility iteration, will default to 1 (no successive over-relaxation)')
if w < 0 or w > 1:
    w = 1
    print('Successive over-relaxation coefficient provided is not between 0 and 1. If doing solubility iteration, will default to 1 (no successive over-relaxation)')

# Read in information on all the molecules in the mixture 
strucs = [] # List of all the structure files to be read in
confs_of = []   # An index for each molecule starting from 0; the same index applies to every conformer of that molecule
mults = []  # A number for the geometrical degeneracy of each conformer, in the same oder the molecules are read in
mol_frac = []   # The mol fraction of each molecule (not conformer) in the mixture
names = []  # List of the names of the molecules in the mixture
for i in range(8,len(inputs)):
    new_molecule_info = inputs[i].split()
    name = new_molecule_info[0] # name - should be the same name the orcacosmo file is saved under (minus number and extension)
    names.append(name)
    read_molfrac = float(new_molecule_info[1])    # mol fraction
    file_loc = new_molecule_info[2] # path to directory containing files
    print('Reading in molecule {0} from {1}'.format(name,file_loc))
    nconfs = int(new_molecule_info[3])  # number of conformers
    # Read in conformer multiplicities - numbers indicating their degeneracy
    if len(new_molecule_info) > 4:
        read_mults = list([int(new_molecule_info[j]) for j in range(4,4+nconfs)])
    # If conformer multiplicities aren't given, set all to 1 (they will normally be 1 anyway)
    else:
        read_mults = [1]*nconfs
        print('Conformer multiplicities were not given. Will take all to be 1')
    # If conformer multiplicities aren't given for all conformers, set all to 1
    if len(read_mults) < nconfs:
        read_mults = [1]*nconfs
        print('Conformer multiplicities were not given for all conformers. Will take all to be 1')
    for j in range(nconfs):
        strucs.append('{0}/{1}_c{2}.orcacosmo'.format(file_loc,name,str(j).rjust(3,'0')))
        confs_of.append(i-8)
    for mult in read_mults:
        mults.append(mult)
    mol_frac.append(read_molfrac)
    print('    mol fraction = {0}; n_conformers = {1}; conformer multiplicities = {2}'\
          .format(read_molfrac,nconfs,read_mults))

# Get conformer mol fractions of each unmixed molecule (mixture of conformers) to use as refstates later
if calc_type == 'all' or calc_type == 'mixed_only':
    print('~~~~~~')
    print('Getting conformer distributions of pure molecules for use in reference states')
    print('~~~~~~')
    pure_molecules = {}
    for i in range(len(mol_frac)):
        print('Molecule {0}'.format(i))
        pure_molecules['{0}'.format(i)] = {}
        pure_molecules['{0}'.format(i)]['strucs'] = []
        pure_molecules['{0}'.format(i)]['confs_of_mol'] = []
        pure_molecules['{0}'.format(i)]['confs_of_individ'] = []
        pure_molecules['{0}'.format(i)]['mults'] = []
        # Set up info on identities of conformers of each molecule to feed into conformer function
        for j in range(len(confs_of)):
            if confs_of[j] == i:
                pure_molecules['{0}'.format(i)]['strucs'].append(strucs[j])
                pure_molecules['{0}'.format(i)]['confs_of_mol'].append(confs_of[j])
                pure_molecules['{0}'.format(i)]['confs_of_individ'].append(0)   # To allow the function to work on only one molecule
                pure_molecules['{0}'.format(i)]['mults'].append(mults[j])
        # Run conformer function for each pure molecule (mix of conformers)
        pure_molecules['{0}'.format(i)]['mus'],\
            pure_molecules['{0}'.format(i)]['Last iteration results'],\
                pure_molecules['{0}'.format(i)]['molfracs'],\
                    pure_molecules['{0}'.format(i)]['molweights'],\
                        pure_molecules['{0}'.format(i)]['en_tots'] = \
                        conf_calcs(pure_molecules['{0}'.format(i)]['strucs'],\
                                   pure_molecules['{0}'.format(i)]['confs_of_individ'],\
                                       pure_molecules['{0}'.format(i)]['mults'],[1],T=T)

# Get conformer mol fractions for desired mixture (or initial guess if iterating to saturation)
mus_mix,last_it_res_mix,all_molfracs_mix,molweights_mix,en_tots = conf_calcs(strucs,confs_of,mults,mol_frac,T=T)

# If not iterating to saturation, perform a COSMO-RS calculation on the conformer mixture with respect to selected reference states to get activity coefficients
if sat == 'no':
    # Print conformer mole fractions and weights to a file
    with open('ConfWeights.txt','w') as f:
        f.write('Mole fractions in mixture: {0}\n'.format(all_molfracs_mix))
        f.write('Conformer mole weights in mixture: {0}'.format(molweights_mix))

    # Run COSMO-RS calculations with real refstates
    print('\n----------------------------------------------------------')
    print('Results of COSMO-RS calculations with real refstates')

    if calc_type == 'all' or calc_type == 'pure_only':
    # Using pure component refstate (each conformer compared individually against its own pure component)
        print('Using pure component refstates for each conformer')
        calculation = {
                'concentrations': np.array([all_molfracs_mix]),
                'temperatures' : np.array([T]),
                'components' : strucs,
                'reference_state_types' : np.array([0]),
                'reference_state_concentrations' : np.array([[]]),
                'component_indices' : [i for i in range(len(all_molfracs_mix))]
        }
        calculations = [calculation]

        calculations = fill_missing_calculation_structures(calculations,options) 

        openCOSMORS.initialize()
        openCOSMORS.loadMolecules(options, parameters, strucs)
        openCOSMORS.loadCalculations(calculations)
        calculations = openCOSMORS.calculate(parameters, calculations, False)

        print('\n')
        print('Total logarithmic activity coefficient: \n', calculations[0]['ln_gamma_x_SR_calc'])
        print('Residual logarithmic activity coefficient: \n',calculations[0]['ln_gamma_x_SR_residual_calc'])
        print('Combinatorial logarithmic activity coefficient: \n',calculations[0]['ln_gamma_x_SR_combinatorial_calc'])
        print('\n')

        # For each component, determine overall ln(gamma) from individual conformer results using the conformational partition function 
        for j in range(len(mol_frac)):
            component_gammatots = []
            component_entots = []
            for k in range(len(confs_of)):
                if confs_of[k] == j:
                    component_gammatots.append(calculations[0]['ln_gamma_x_SR_calc'][0][k])    
                    component_entots.append(en_tots[k])
            partition_mu_conformerrefsts = confpartfun(component_gammatots,component_entots)
            partition_lngam_conformerrefsts = partition_mu_conformerrefsts/(R*T)
            # Print results to a file
            with open('ActivityCFs_pureconfs.txt','a') as f:
                f.write('ln(gamma) {0}    {1}\n'.format(names[j],partition_lngam_conformerrefsts))

    # Using refstates of the calculated conformer mixture for each molecule
    if calc_type == 'all' or calc_type == 'mixed_only':
        w_avs = []
        print('Using refstates reflecting the mix of conformers for each unmixed molecule')
        print('--------')
        # Loop through all molecules, treating each as a reference state in turn
        for i in range(len(pure_molecules)):
            refst_fracs = []
            reached_the_molecule = 'no'
            for j in range(len(strucs)):
                # Read the mole fractions of the conformers for the molecule which is the reference state 
                if confs_of[j] == i and reached_the_molecule =='no':
                    reached_the_molecule ='yes'
                    for k in range(len(pure_molecules['{0}'.format(i)]['molfracs'])):
                        refst_fracs.append(pure_molecules['{0}'.format(i)]['molfracs'][k])
                # Assign mole fractions of 0 for all other conformers in the reference mixture
                elif confs_of[j] != i:
                    refst_fracs.append(0.0)
            print('Refstate is conformer mix of pure molecule {0} ({1})'.format(i,names[i]))
            print('Refstate mol fractions are:',refst_fracs)
           
            # Run the COSMO-RS
            calculation = {
                    'concentrations': np.array([all_molfracs_mix]),
                    'temperatures' : np.array([T]),
                    'components' : strucs,
                    'reference_state_types' : np.array([2]),
                    'component_indices' :  [i for i in range(len(all_molfracs_mix))],
                    'reference_state_concentrations' : np.array([refst_fracs])
                }
            calculations = [calculation]
    
            calculations = fill_missing_calculation_structures(calculations,options) 

            openCOSMORS.initialize()
            openCOSMORS.loadMolecules(options,parameters,strucs)
            openCOSMORS.loadCalculations(calculations)
            calculations = openCOSMORS.calculate(parameters, calculations, False)

            print('\n')
            print('Total logarithmic activity coefficient: \n', calculations[0]['ln_gamma_x_SR_calc'])
            print('Residual logarithmic activity coefficient: \n',calculations[0]['ln_gamma_x_SR_residual_calc'])
            print('Combinatorial logarithmic activity coefficient: \n',calculations[0]['ln_gamma_x_SR_combinatorial_calc'])
            print('\n')

            # Print which molecule is the reference state to a file
            with open('ActivityCFs_mixconfs.txt','a') as f:
                f.write('------Refstate {0}------\n'.format(names[i]))
            # For each component, determine the overall ln(gamma) from the individual values and the conformational partition function
            for j in range(len(mol_frac)):
                component_gammatots = []
                component_entots = []
                for k in range(len(confs_of)):
                    if confs_of[k] == j:
                        component_gammatots.append(calculations[0]['ln_gamma_x_SR_calc'][0][k])    
                        component_entots.append(en_tots[k])
                partition_mu_mixconformerrefsts = confpartfun(component_gammatots,component_entots)
                partition_lngam_mixconformerrefsts = partition_mu_mixconformerrefsts/(R*T)
                # Print activity cf results to file
                with open('ActivityCFs_mixconfs.txt','a') as f:
                    f.write('ln(gamma) {0}   {1} (ref {2})\n'.format(names[j],partition_lngam_mixconformerrefsts,names[i]))

# If doing saturation part, run that instead of single activity calculation
else:
    for i in range(len(names)):
        if names[i] == sat:
            mol_to_sat = i
    try:
        print('Will find solubility of {0} (molecule {1}) at saturation'.format(sat,mol_to_sat))
    except:
        sys.exit('Requested to find solubility at saturation of a molecule not in the names list. Exiting.')

    # Set up information for the saturation iteration
    molfrac_diff = float('inf')     # These two varialbles define the while loop, so they are defined before it
    new_molfrac_partition = 1       # So they must be assigned values here
    molfrac_tosat = mol_frac[mol_to_sat]
    if Tm == 'liquid':
        print('Compound specified to be liquid at working temp. Using liquid settings...')
    elif float(Tm) < T:
        Tm = 'liquid'
        print('Tm is lower than working temp. Using liquid settings...')
    else:
        print('Tm is not lower than working temp. Using solid settings...')

    if Tm != 'liquid':
        Tm = float(Tm)
        try:
            Gfus = float(Gfus_input)
            print('Reading Delta G (fusion) from file')
        except:
            if Gfus_input == 'from_Hfus':
                print('Getting delta G (fusion) from inputted delta H (fusion)')
                Gfus = -float(Hfus)*(1-(T/Tm))     # expression taken from 10.1146/annurev-chembioeng-073009-100903
            elif Gfus_input == 'MyrdalYalkowsky':
                print('Estimating detla G (fusion) with the method of Myrdal and Yakowlsky')
                Gfus = GfusMY(T,Tm,SMILES)
            else:
                sys.exit('Need a delta G (fusion) because molecule is solid, and was unable to read or calculate one from the input. Exiting.')

    molfrac_diff = float('inf')     # These two variables define the while loop, so they are defined before it
    new_molfrac_partition = mol_frac[mol_to_sat]       # Used for successive over-relaxation - set initial mole frac to be the one we read in
    molfrac_tosat = mol_frac[mol_to_sat]    
    # Set variable x, mole fractions for initial guess population
    x = np.array([all_molfracs_mix])
    # Solubility saturation for pure conformer case
    if calc_type == 'all' or calc_type == 'pure_only':
        # Using pure component refstate (each conformer compared individually against its own pure component)
        print('----------------------')
        print('Using pure component refstates for each conformer')

        new_all_molfracs_mix,calculations,new_molweights_mix,saturated_molfrac  =\
            run_saturation(x,'pure_component',molfrac_diff,new_molfrac_partition,molfrac_tosat)
        
        print('Mole fraction solubility has converged to within {0} (absolute) and {1}*solubility'.format(sat_tol,sat_tol_frac))     
        print('Mole fraction solubility: ',saturated_molfrac)
        with open('finalsol_p.txt','w') as f:
            f.write('Final solubility {0}\n'.format(saturated_molfrac))

        # For each component, determine overall ln(gamma) from individual conformer results using the conformational partition function 
        for j in range(len(mol_frac)):
            component_gammatots = []
            component_entots = []
            for k in range(len(confs_of)):
                if confs_of[k] == j:
                    component_gammatots.append(calculations[0]['ln_gamma_x_SR_calc'][0][k])    
                    component_entots.append(en_tots[k])
            partition_mu_conformerrefsts = confpartfun(component_gammatots,component_entots)
            partition_lngam_conformerrefsts = partition_mu_conformerrefsts/(R*T)
            # Print results to a file
            with open('ActivityCFs_pureconfs_sat.txt','a') as f:
                f.write('ln(gamma) {0}    {1}\n'.format(names[j],partition_lngam_conformerrefsts))

        # Print conformer weights to a file
        with open('ConfWeights_pure_sat.txt','w') as f:
            f.write('Mole fractions in final mixture: {0}\n'.format(new_all_molfracs_mix))
            f.write('Conformer mole weights in final mixture: {0}'.format(new_molweights_mix))

    # Solubility saturation for mixed conformer case:
    if calc_type == 'all' or calc_type == 'mixed_only':
        # Using the refstate of the calculated conformer mixture for the solute
        print('----------------------')
        print('Using the refstate reflecting the mix of conformers for the solute')
        refst_fracs = []
        for i in range(len(strucs)):
            if confs_of[i] == mol_to_sat:
                refst_fracs.append(pure_molecules[str(mol_to_sat)]['molfracs'][i])
            else:
                refst_fracs.append(0.0)
        print('Refstate is conformer mix of pure molecule {0}'.format(mol_to_sat))
        print('Refstate mol fractions are:',refst_fracs)

        new_all_molfracs_mix,calculations,new_molweights_mix,saturated_molfrac  =\
            run_saturation(x,refst_fracs,molfrac_diff,new_molfrac_partition,molfrac_tosat)
        
        print('Mole fraction solubility has converged to within {0} (absolute) and {1}*solubility'.format(sat_tol,sat_tol_frac))     
        print('Mole fraction solubility: ',saturated_molfrac)
        with open('finalsol_m.txt','w') as f:
            f.write('Final solubility {0}\n'.format(saturated_molfrac))

        # Print which molecule is the reference state to a file
        with open('ActivityCFs_mixconfs_sat.txt','a') as f:
            f.write('------Refstate {0}------\n'.format(names[mol_to_sat]))
        # For each component, determine the overall ln(gamma) from the individual values and the conformational partition function
        for i in range(len(mol_frac)):
            component_gammatots = []
            component_entots = []
            for j in range(len(confs_of)):
                if confs_of[j] == i:
                    component_gammatots.append(calculations[0]['ln_gamma_x_SR_calc'][0][j])   
                    component_entots.append(en_tots[j])
            partition_mu_mixconformerrefsts = confpartfun(component_gammatots,component_entots)
            partition_lngam_mixconformerrefsts = partition_mu_mixconformerrefsts/(R*T)
            # Print activity cf results to file
            with open('ActivityCFs_mixconfs_sat.txt','a') as f:
                f.write('ln(gamma) {0}   {1} (ref {2})\n'.format(names[i],partition_lngam_mixconformerrefsts,names[mol_to_sat]))

        # Print conformer weights to a file
        with open('ConfWeights_mix_sat.txt','w') as f:
            f.write('Mole fractions in final mixture: {0}\n'.format(new_all_molfracs_mix))
            f.write('Conformer mole weights in final mixture: {0}'.format(new_molweights_mix))

end = datetime.datetime.now()
print('time taken is ',end-start)


