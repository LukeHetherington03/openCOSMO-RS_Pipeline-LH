"""
molecule_utils.py

Reusable helper functions for molecule I/O, multiplicity, RMSD, etc.
"""

import os
from rdkit import Chem
from rdkit.Chem import rdMolAlign, rdDetermineBonds, rdMolDescriptors
from rdkit.Geometry import Point3D
import csv

class MoleculeUtils:
    @staticmethod
    def rotatable_bonds(mol):
        """Return number of rotatable bonds."""
        from rdkit.Chem import rdMolDescriptors
        return rdMolDescriptors.CalcNumRotatableBonds(mol)

    @staticmethod
    def multiplicity(mol, charge=0):
        """Return spin multiplicity (1=singlet, 2=doublet)."""
        mol = Chem.AddHs(mol)
        electrons = sum(atom.GetAtomicNum() for atom in mol.GetAtoms())
        return 1 if (electrons - charge) % 2 == 0 else 2

    @staticmethod
    def save_xyz(mol, conf_id, filepath, inchi_key=None, method=None):
        """Write conformer to xyz file with provenance in comment line."""
        conf = mol.GetConformer(conf_id)
        atoms = mol.GetAtoms()
        with open(filepath, "w") as f:
            f.write(f"{len(atoms)}\n")
            f.write(f"{inchi_key} conf={conf_id} generated by {method}\n")
            for atom in atoms:
                pos = conf.GetAtomPosition(atom.GetIdx())
                f.write(f"{atom.GetSymbol()} {pos.x:.6f} {pos.y:.6f} {pos.z:.6f}\n")



    @staticmethod
    def save_conformer(conformer, filepath, comment=None):
        """Save conformer with optional energy comment."""
        if comment is None and conformer.HasProp("energy"):
            energy_value = f"{conformer.GetDoubleProp('energy'):.16f}"
            comment = f"energy: {energy_value}"
        mol = conformer.GetOwningMol()
        with open(filepath, "w") as f:
            f.write(f"{mol.GetNumAtoms()}\n{comment}\n")
            for i in range(mol.GetNumAtoms()):
                pos = conformer.GetAtomPosition(i)
                f.write(f"{mol.GetAtomWithIdx(i).GetSymbol()} {pos.x:.6f} {pos.y:.6f} {pos.z:.6f}\n")

    @staticmethod
    def load_xyz(filepath):
        """Read xyz file into RDKit Conformer object."""
        with open(filepath, "r") as f:
            n_atoms = int(f.readline().strip())
            comment = f.readline().strip()
            conformer = Chem.Conformer(n_atoms)
            atom_symbols = []
            for i in range(n_atoms):
                sym, x, y, z = f.readline().split()
                atom_symbols.append(sym)
                conformer.SetAtomPosition(i, Point3D(float(x), float(y), float(z)))
        return conformer, atom_symbols, comment

    @staticmethod
    def rmsd(probe_mol, ref_mol, probe_conf=0, ref_conf=0, heavy_only=True):
        """Compute RMSD between two conformers."""
        if heavy_only:
            probe = Chem.RemoveHs(probe_mol)
            ref = Chem.RemoveHs(ref_mol)
        else:
            probe, ref = probe_mol, ref_mol
        return rdMolAlign.GetBestRMS(probe, ref, probe_conf, ref_conf)


    @staticmethod
    def filter_xyz_with_lookup(optimisation_dir, lookup_csv=None):
        """
        Recursively collect .xyz files from optimisation_dir.
        If lookup_csv is provided, filter to only those listed.

        Parameters
        ----------
        optimisation_dir : str
            Path to folder containing optimised conformers.
        lookup_csv : str, optional
            Path to pruning lookup CSV. If provided, only conformers listed here are processed.

        Returns
        -------
        xyz_files : list of str
            List of file paths to .xyz files.
        """
        # Collect all .xyz files recursively
        xyz_files = []
        for root, _, files in os.walk(optimisation_dir):
            for f in files:
                if f.endswith(".xyz"):
                    xyz_files.append(os.path.join(root, f))

        if not xyz_files:
            raise RuntimeError(f"No XYZ files found in {optimisation_dir}")

        # If lookup CSV is provided, filter
        if lookup_csv:
            if not os.path.exists(lookup_csv):
                raise FileNotFoundError(f"Lookup CSV not found: {lookup_csv}")
            allowed_ids = set()
            with open(lookup_csv, newline="") as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    allowed_ids.add(row.get("lookup_id") or row.get("filename"))
            xyz_files = [f for f in xyz_files if os.path.splitext(os.path.basename(f))[0] in allowed_ids]

        if not xyz_files:
            raise RuntimeError(f"No XYZ files left to process after filtering with lookup {lookup_csv}")

        return xyz_files

    def xyz_to_cosmo_input(xyz_file, out_file,
                        backend="orca",
                        method="B3LYP",
                        basis="def2-SVP",
                        epsilon=78.39,
                        charge=0,
                        multiplicity=1):
        with open(xyz_file) as f:
            lines = f.readlines()
        # First line = atom count, second line = comment
        coords = "".join(lines[2:]).strip()

        if backend == "orca":
            template = f"""! {method} {basis} TightSCF
    %cosmo
    epsilon {epsilon}
    end

    * xyz {charge} {multiplicity}
    {coords}
    *
    """
        with open(out_file, "w") as f:
            f.write(template)
        return out_file
    
    
    @staticmethod
    def xyz_to_orca_inp(xyz_file, out_file,
                        method="B3LYP",
                        basis="def2-SVP",
                        solvent="Water",
                        charge=0,
                        multiplicity=1):
        with open(xyz_file) as f:
            lines = f.readlines()
        coords = "".join(lines[2:]).strip()

        template = f"""! {method} {basis} TightSCF CPCM({solvent})

* xyz {charge} {multiplicity}
{coords}
*
"""
        with open(out_file, "w") as f:
            f.write(template)
        return out_file


